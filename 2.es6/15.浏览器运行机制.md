# 知识点

#### 区分进程和线程
```js
- 计算机的核心是CPU。承担所有的计算任务，就像一个工厂，时刻运行
- 但是工厂电力有限，一次只能运行一个车间。即单个CPU一次只能执行一个任务。
- 进程就像工厂的车间，任意时刻总是只有一个车间在运行。
- 一个车间里有很多工人，他们协同完成一个任务。线程就像车间里的工人。一个进程可以包含多个线程
- 车间的空间是共享的，每个线程都可以使用这些空间
- 一个线程使用某些共享内存时，其他线程必须等它结束才可以使用这一块内存
```

### 宏任务、微任务
- 微任务：promise.then, MutationObserver, process.nextTick

- 宏任务：script, ajax, 事件, requestFrameAnimation, setTimeout, setInterval, setImmediate, MessageChannel, I/O, UI rendering

### [浏览器线程等相关知识](https://juejin.im/post/5a6547d0f265da3e283a1df7)

```js
- 进程是一个工厂，工厂有它的独立资源
- 工厂之间相互独立
- 线程是工厂中的工人，多个工人协作完成任务
- 工厂内有一个或多个工人
- 工人之间共享空间
```

```js
- 工厂的资源 -> 系统分配的内存（独立的一块内存）
- 工厂之间的相互独立 -> 进程之间相互独立
- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务
- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成
- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
```

* 进程是CPU资源分配的最小单位(是能拥有资源和独立运行的最小单位)
* 线程是CPU调度的最小单位(线程是建立在进程的基础上的一次程序运行单位,一个进程中可以有多个线程)


#### tips
* 不同进程之间可以通信，不过代价较大
* 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。

### 浏览器是多进程的
---
首先：
* 浏览器是多进程的
* 浏览器之所以能够运行，是因为系统给他的进程分配了资源(cpu、内存)
* 简单点理解，没打开一个Tab页就相当于创建了一个独立的浏览器进程


** 注意： ** 在这里浏览器应该也有自己的优化机制，，有时候打开多个tab页后，可以在chrome任务管理器中看到，有些进程被合并了(所以每一个Tab标签页对应一个进程并不一定是绝对的)

#### 浏览器包含哪些进程？

1. Browser进程：浏览器的主进程(负责协调、主控)，只有一个。作用：
    - 负责浏览器显示界面，与用户交互。如前进、后退等
    - 负责各个页面的管理，创建和销毁其他进程
    - 将renderer进程得到的内存中的Bitmap绘制到用户界面上
    - 网络资源的管理、下载等
2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时菜菜创建
3. GPU进程：最多一个、用于3D绘制等
4. 浏览器渲染进程(浏览器内核)(renderer进程，内部是多线程)：默认每个Tab页面一个进程，互不影响。主要作用为：
    - 页面渲染，脚本执行，事件处理

强化记忆：在浏览器中打开一个网页就相当于新起了一个进程，进程内有自己的多线程

#### 浏览器多进程的优势：
* 避免单个page crash影响整个浏览器
* 避免第三方插件从热爱生活影响整个浏览器
* 多进程充分利用多核优势
* 方便使用沙沙盒隔离插件等进程

#### 浏览器内核(渲染进程)
页面的渲染、js的执行、事件的循环都在这个进程内进行
**浏览器的渲染进程是多线程的**
以下是渲染进程的线程：
1. GUI渲染线程
    - 负责渲染浏览器界面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等。
    - 当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行
    - 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起(相当于被冻结了)，GUI更新会保存再一个队列中等到JS引擎空闲时立即被执行
2. JS引擎线程
    - 也成js内核，负责处理javascript脚本程序。(例如V8引擎)
    - JS引擎线程负责解析javascript脚本，运行代码
    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序
    - 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行时间过长，这样就会导致页面的渲染不连贯，导致页面渲染加载阻塞
3. 事件触发线程
    - 归属于浏览器而不是JS引擎，用来控制事件循环(可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助)
    - 当JS引擎执行代码块如setTimeout时(也可以来自浏览器内核的其他线程，如鼠标点击、ajax异步请求等)，会将对应任务添加到事件线程中
    - 当对应的事件符合触发条件触发时，该线程会把事件添加到待处理队伍列表的队尾，等待JS引擎的处理
    - 注意，由于js的单线程关系，所以这些处理队列中的事件都得排队等待js引擎处理(当JS空闲时才会执行)
4. 定时器触发线程
    - setTimeout、setInterval
    - 浏览器定时技术器并不是由javascript引擎技术的，因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响计数器的准确
    - 因此通过单独的线程来计数并触发定时(计时完毕后添加到事件队列中，等待JS引擎空闲后执行)
    - 注意，W3C在HTML标准中规定，规定要求setTimeout中抵御4ms的时间间隔算为4ms
    - setInterval的问题：setInterval的回调函数可能累积多个，造成代码执行异常、浏览器最小化时setInterval也在一直输出回调函数但是函数不会执行会在打开窗口的一瞬间全部执行
5. 异步http请求线程
    - 在XMLHTTPRequest在连接后是通过浏览器新开一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更时间，将这个回调函数放到事件队列中，再由JavaScript引擎执行

#### Browser进程和浏览器内核(renderer进程)的通信过程
webWorker是浏览器新开的一个独立的进程用来执行一些耗时的计算，在适当时候使用postMassage将结果传递回页面而不会阻塞js执行
sharedWorker是多页面共享的webWorker

### 浏览器渲染流程
1. 浏览器输入url，主进程接管，开一个下载线程
2. 然后进行http请求，等待响应获取内容
3. 将内容通过RendererHost接口转交给Renderer进程
4. 开始渲染
    - 解析html建立DOM树
    - 解析css构建render树
    - 布局render树，
    - 绘制render树
    - 浏览器会将各层的信息发送给GPU，GPU会将各层合成(composite)显示在屏幕上
    - load事件触发，开始执行js
* load与DOMContentLoaded事件
    - 当DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片
    - 当onloaded事件触发时，页面上所有DOM，样式表、脚本、图片都已经加载完成了(渲染完毕了)
    - 所以DOMContentLoaded -> load
##### tips
1. css加载是否会阻塞dom树渲染？
    css加载不会阻塞DOM树解析。异步加载时DOM树正常构建，但是会阻塞render树渲染，因为render树需要css的信息
2. 图片加载与DOM树渲染
    个人猜测不会阻塞，因为常常在浏览器里见到图片在页面绘制完成后才加载出来

#### 普通图层和复合图层
    - 普通图层：基本的文本流
    - 默认复合图层：absolute、fixed，脱离文档流
    - 新的复合图层：通过硬件加速方式，单独分配资源，如translate3d、translateZ、opacity属性/过度动画、video、iframe、canvas、webgl等元素


### js运行机制
到这里，浏览器页面初次渲染已经完成了。
首先，在头部引入的js会阻塞body中html的解析，此时页面是一片空白。

顺序执行，异步事件加入队列等同步任务执行完成之后执行异步任务，而每一个异步任务内都可能包含一些列同步任务，这就是宏任务与微任务的区分
#### macrotask和microtask
```js
console.log('script start');    // 1

setTimeout(function() {                 // 宏任务
    console.log('setTimeout');  // 5
}, 0);

Promise.resolve().then(function() { // 微任务
    console.log('promise1');    // 3
}).then(function() {
    console.log('promise2');    // 4
});

console.log('script end');      // 2

```
* 宏任务：主代码块、setTimeout、setInterval、MessageChannel、以及事件队列中的每一个(用户事件、异步回调等)。 MessageChannel优先级高于settimeout
* 微任务：Promise、process.nextTick
另：在node环境下，process.nextTick的优先级高于Promise，也就是可以理解为在一个宏任务的同步代码执行结束后，会先执行微任务队列中的nextTick部分，然后才会执行微任务中的Promise部分

执行流程如下：进入一个宏任务后，现将所有同步代码执行完毕，然后进入一个微任务，微任务执行完成之后进入下一个微任务，当当前宏任务下的所有微任务执行完毕后进行浏览器渲染，然后进入下一个宏任务

##### MutationObserver
    - MutationObserver可以用来实现microtask(它属于microtask，优先级小于promise，一般是promise不支持时才会这样做)，他是html5的新特性，作用是：监听一个DOM变动，当DOM对象树发生任何变动时，Mutation Observer会得到通知
    - Vue中就曾用他来模拟nextTick
